JVM内存模型：
	1.堆：存放对象实例，几乎所有的对象实例都在这里分配内存
		堆的内存由 -Xms 指定，默认是物理内存的1/64；最大的内存由 -Xmx 指定，默认是物理内存的1/4.
		默认空余的堆内存小于40%时，就会增大，直到 -Xmx 设置的内存。具体的比例可以由 -XX:MinHeapFreeRatio 指定.
		空余的内存大于70%时，就会减少内存，直到 -Xms 设置的大小。具体由 -XX:MaxHeapFreeRatio 指定.
	2.虚拟机栈
		虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息.
		本地方法栈则是为虚拟机使用到的Native方法服务.
	3.方法区：存储已被虚拟机加载的类元数据信息（元空间）
		1）有时候也称为永久代，在该区很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载.
		2）方法区主要用来存储已被虚拟机记载的类的信息、常量、静态变量和即时编译器编译后的代码等数据.该区域是被线程共享的.
		3）方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。
	4.程序计数器：当前线程所执行的字节码的行号指示器

总结：
	名称					 特征								作用							配置				  					异常
	栈区  	线程私有，使用一段连续的内存空间  存放局部变量表、操作栈、动态链接、方法出口    	    -XSs				StackOverflowError OutOfMemoryError
	堆    	线程共享，生命周期与虚拟机相同                保存对象实例					-Xms -Xmx -Xmm						OutOfMemoryError
 程序计数器  线程私有，占用内存小			                字节码行号						无				  					 无
   方法区    线程共享                        存储类加载信息、常量、静态变量等       -XX:PermSize -XX:MaxPermSize 			    OutOfMemoryError

JVM内存结构：
	VM的内存空间分为3大部分：
    	堆内存
    	方法区
    	栈内存
    其中栈内存可以再细分为java虚拟机栈和本地方法栈,堆内存可以划分为新生代和老年代,新生代中还可以再次划分为Eden区、From Survivor区和To Survivor区。
	其中一部分是线程共享的，包括 Java 堆和方法区；另一部分是线程私有的，包括虚拟机栈和本地方法栈，以及程序计数器这一小部分内存。 

堆内存（Heap）：
	java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。堆是被所有线程共享的区域，实在虚拟机启动时创建的。堆里面存放的都是对象的实例（new 出来的对象都存在堆中）。
	此内存区域的唯一目的就是存放对象实例（new的对象），几乎所有的对象实例都在这里分配内存。

	堆内存分为两个部分：年轻代和老年代。我们平常所说的垃圾回收，主要回收的就是堆区。更细一点划分新生代又可划分为Eden区和2个Survivor区（From Survivor和To Survivor）。

	但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代已经被移除。 

	新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )
	默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 

方法区（Method Area）：
	 方法区也称”永久代“，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。

	在JDK8之前的HotSpot JVM，存放这些”永久的”的区域叫做“永久代(permanent generation)”。永久代是一片连续的堆空间，在JVM启动之前通过在命令行设置参数-XX:MaxPermSize来设定永久代最大可分配的内存空间，默认大小是64M（64位JVM默认是85M）。

	随着JDK8的到来，JVM不再有 永久代(PermGen)。但类的元数据信息（metadata）还在，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory。

方法区或永生代相关设置

    -XX:PermSize=64MB 最小尺寸，初始分配
    -XX:MaxPermSize=256MB 最大允许分配尺寸，按需分配
    XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled 设置垃圾不回收
    默认大小
    -server选项下默认MaxPermSize为64m
    -client选项下默认MaxPermSize为32m

虚拟机栈(JVM Stack)：
	java虚拟机栈是线程私有，生命周期与线程相同。创建线程的时候就会创建一个java虚拟机栈。
	虚拟机执行java程序的时候，每个方法都会创建一个栈帧，栈帧存放在java虚拟机栈中，通过压栈出栈的方式进行方法调用。
	栈帧又分为一下几个区域：局部变量表、操作数栈、动态连接、方法出口等。
	平时我们所说的变量存在栈中，这句话说的不太严谨，应该说局部变量存放在java虚拟机栈的局部变量表中。
	java的8中基本类型的局部变量的值存放在虚拟机栈的局部变量表中，如果是引用型的变量，则只存储对象的引用地址。 

本地方法栈(Native Stack)：
	本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 

程序计数器（PC Register）：
	 程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。
	Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。

直接内存：
	直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。

JVM内存参数设置：
    -Xms设置堆的最小空间大小。
    -Xmx设置堆的最大空间大小。
    -Xmn:设置年轻代大小
    -XX:NewSize设置新生代最小空间大小。
    -XX:MaxNewSize设置新生代最大空间大小。
    -XX:PermSize设置永久代最小空间大小。
    -XX:MaxPermSize设置永久代最大空间大小。
    -Xss设置每个线程的堆栈大小
    -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。
    -XX:ParallelGCThreads=20:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。

典型JVM参数配置参考:
    java-Xmx3550m-Xms3550m-Xmn2g-Xss128k
    -XX:ParallelGCThreads=20
    -XX:+UseConcMarkSweepGC-XX:+UseParNewGC

	-Xmx3550m:设置JVM最大可用内存为3550M。
	-Xms3550m:设置JVM促使内存为3550m。此值可以设置与-Xmx相同,以避免每次垃圾回收完成后JVM重新分配内存。
	-Xmn2g:设置年轻代大小为2G。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64m,所以增大年轻代后,将会减小年老代大小。此值对系统性能影响较大,官方推荐配置为整个堆的3/8。
	-Xss128k:设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右。

垃圾回收算法：
	
	1.标记-清除: 这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。 

	2.复制算法: 为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。 于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)

	3. 标记-整理 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 

	4.分代收集 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。 

	1.标记清除
		标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段.
		在标记阶段首先通过根节点（GC Roots）,标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象.
	适用场合：
		存活对象较多的情况下比较高效
		适用于年老代（即旧生代）
	缺点：
		容易产生内存碎片，再来一个比较大的对象时（典型情况：该对象的大小大于空闲表中的每一块大小但是小于其中两块的和），会提前触发垃圾回收.
		扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）.

	2.复制算法
		从根集合节点进行扫描，标记出所有的存活对象，并将这些存活的对象复制到一块新的内存上去，之后将原来的那一块内存全部回收掉.
	现在的商业虚拟机都采用这种收集算法来回收新生代.
	适用场合：
		存活对象较少的情况下比较高效
		扫描了整个空间一次（标记存活队对象并复制移动）
		适用于年轻代（即新生代）：基本上98%的对象是“朝生夕死”的，存活下来的会很少
	缺点：
		需要一块空的内存空间
		需要复制移动对象

	3.标记整理
	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的.
	这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高.
	标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化.
	首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

	4.分代收集算法
	分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。
	在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。 

垃圾回收机制：
	年轻代分为Eden区和survivor区（两块儿：from和to），且Eden:from:to==8:1:1。
	JVM内存结构：
	1）新产生的对象优先分配在Eden区（除非配置了-XX:PretenureSizeThreshold，大于该值的对象会直接进入年老代）；
	2）当Eden区满了或放不下了，这时候其中存活的对象会复制到from区。 （这里，需要注意的是，如果存活下来的对象from区都放不下，则这些存活下来的对象全部进入年老代。之后Eden区的内存全部回收掉。）
	3）之后产生的对象继续分配在Eden区，当Eden区又满了或放不下了，这时候将会把Eden区和from区存活下来的对象复制到to区（同理，如果存活下来的对象to区都放不下，则这些存活下来的对象全部进入年老代），之后回收掉Eden区和from区的所有内存。
	4）如上这样，会有很多对象会被复制很多次（每复制一次，对象的年龄就+1），默认情况下，当对象被复制了15次（这个次数可以通过：-XX:MaxTenuringThreshold来配置），就会进入年老代了。
	5）当年老代满了或者存放不下将要进入年老代的存活对象的时候，就会发生一次Full GC（这个是我们最需要减少的，因为耗时很严重）。

垃圾回收有两种类型：Minor GC 和 Full GC。
	1.Minor GC
	对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。

	2.Full GC
	也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。 

垃圾回收算法总结：
1.年轻代：复制算法
	1) 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
	2)新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空，如此往复。
	3) 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。
	4) 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。

2.年老代：标记-清除或标记-整理
	1) 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
	2) 内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率比较高。
	以上这种年轻代与年老代分别采用不同回收算法的方式称为”分代收集算法”，这也是当下企业使用的一种方式

3. 每一种算法都会有很多不同的垃圾回收器去实现，在实际使用中，根据自己的业务特点做出选择就好。

JVM垃圾收集器有哪些？以及优劣势比较？
1.串行收集器
	串行收集器是最简单的，它设计为在单核的环境下工作（32位或者windows），你几乎不会使用到它。它在工作的时候会暂停整个应用的运行，因此在所有服务器环境下都不可能被使用。
2.并行收集器
	这是JVM默认的收集器，跟它名字显示的一样，它最大的优点是使用多个线程来扫描和压缩堆。缺点是在minor和full GC的时候都会暂停应用的运行。并行收集器最适合用在可以容忍程序停滞的环境使用，它占用较低的CPU因而能提高应用的吞吐（throughput）。
3.CMS收集器
	 CMS是Concurrent-Mark-Sweep的缩写，并发的标记与清除。
	这个算法使用多个线程并发地（concurrent）扫描堆，标记不使用的对象，然后清除它们回收内存。在两种情况下会使应用暂停（Stop the World, STW）：
	1. 当初次开始标记根对象时initial mark。
	2. 当在并行收集时应用又改变了堆的状态时，需要它从头再确认一次标记了正确的对象final remark。

	这个收集器最大的问题是在年轻代与老年代收集时会出现的一种竞争情况（race condition），称为提升失败promotion failure。对象从年轻代复制到老年代称为提升promotion，但有时侯老年代需要清理出足够空间来放这些对象，这需要一定的时间，它收集的速度可能赶不上不断产生的要提升的年轻代对象的速度，这时就需要做STW的收集。STW正是CMS想避免的问题。为了避免这个问题，需要增加老年代的空间大小或者增加更多的线程来做老年代的收集以赶上从年轻代复制对象的速度。

	除了上文所说的内容之外，CMS最大的问题就是内存空间碎片化的问题。CMS只有在触发FullGC的情况下才会对堆空间进行compact。如果线上应用长时间运行，碎片化会非常严重，会很容易造成promotion failed。为了解决这个问题线上很多应用通过定期重启或者手工触发FullGC来触发碎片整理。

	对比并行收集器它的一个坏处是需要占用比较多的CPU。对于大多数长期运行的服务器应用来说，这通常是值得的，因为它不会导致应用长时间的停滞。但是它不是JVM的默认的收集器。
4.G1收集器
	如果你的堆内存大于4G的话，那么G1会是要考虑使用的收集器。它是为了更好支持大于4G堆内存在JDK 7 u4引入的。G1收集器把堆分成多个区域，大小从1MB到32MB，并使用多个后台线程来扫描这些区域，优先会扫描最多垃圾的区域，这就是它名称的由来，垃圾优先Garbage First。

	如果在后台线程完成扫描之前堆空间耗光的话，才会进行STW收集。它另外一个优点是它在处理的同时会整理压缩堆空间，相比CMS只会在完全STW收集的时候才会这么做。

	使用过大的堆内存在过去几年是存在争议的，很多开发者从单个JVM分解成使用多个JVM的微服务（micro-service）和基于组件的架构。其他一些因素像分离程序组件、简化部署和避免重新加载类到内存的考虑也促进了这样的分离。

	除了这些因素，最大的因素当然是避免在STW收集时JVM用户线程停滞时间过长，如果你使用了很大的堆内存的话就可能出现这种情况。另外，像Docker那样的容器技术让你可以在一台物理机器上轻松部署多个应用也加速了这种趋势。 

常见的垃圾收集器有3类：
1.新生代的收集器包括：
    Serial
    PraNew
    Parallel Scavenge

2.老年代的收集器包括：
    Serial Old
    Parallel Old
    CMS

3.回收整个Java堆(新生代和老年代)
    G1收集器

新生代垃圾收集器：
1.Serial串行收集器-复制算法
	Serial收集器是新生代单线程收集器，优点是简单高效，算是最基本、发展历史最悠久的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。 
	Serial收集器依然是虚拟机运行在Client模式下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。

2.ParNew收集器-复制算法
	ParNew收集器是新生代并行收集器，其实就是Serial收集器的多线程版本。
	除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。 

3.Parallel Scavenge（并行回收）收集器-复制算法
	Parallel Scavenge收集器是新生代并行收集器，追求高吞吐量，高效利用 CPU。
	该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
	停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 

老年代垃圾收集器：
1.Serial Old 收集器-标记整理算法
	Serial Old是Serial收集器的老年代版本，它同样是一个单线程(串行)收集器，使用标记整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。
	如果在Server模式下，主要两大用途：
	（1）在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
	（2）作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 

2.Parallel Old 收集器-标记整理算法
	Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。 

3.CMS收集器-标记整理算法
	CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。
	目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

	CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：
	（1）初始标记
	（2）并发标记
	（3）重新标记
	（4）并发清除
	其中，初始标记、重新标记这两个步骤仍然需要“Stop The World” 

	CMS收集器主要优点：
    并发收集
    低停顿

	CMS三个明显的缺点：
	（1）CMS收集器对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。
	（2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。
	（3）CMS是基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前出发Full GC。 

新生代和老年代垃圾收集器：
	1.G1收集器-标记整理算法
	JDK1.7后全新的回收器, 用于取代CMS收集器。

	G1收集器的优势：
    独特的分代垃圾回收器,分代GC: 分代收集器, 同时兼顾年轻代和老年代
    使用分区算法, 不要求eden, 年轻代或老年代的空间都连续
    并行性: 回收期间, 可由多个线程同时工作, 有效利用多核cpu资源
    空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片
    可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿

	G1收集器的阶段分以下几个步骤：
	1、初始标记（它标记了从GC Root开始直接可达的对象）
	2、并发标记（从GC Roots开始对堆中对象进行可达性分析，找出存活对象）
	3、最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）
	4、筛选回收（首先对各个Region的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region） 

 JVM垃圾收集器总结
下面给出配置回收器时，经常使用的参数：
    -XX:+UseSerialGC：在新生代和老年代使用串行收集器
    -XX:+UseParNewGC：在新生代使用并行收集器
    -XX:+UseParallelGC ：新生代使用并行回收收集器，更加关注吞吐量
    -XX:+UseParallelOldGC：老年代使用并行回收收集器
    -XX:ParallelGCThreads：设置用于垃圾回收的线程数
    -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器
    -XX:ParallelCMSThreads：设定CMS的线程数量
    -XX:+UseG1GC：启用G1垃圾回收器

JVM内存调优：
	对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。
1.Full GC
	会对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比较慢，因此应该尽可能减少Full GC的次数。

2.导致Full GC的原因
	1)年老代（Tenured）被写满
	调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在旧生代创建对象 。
	2)持久代Pemanet Generation空间不足
	增大Perm Gen空间，避免太多静态对象 ，控制好新生代和旧生代的比例
	3)System.gc()被显示调用
	垃圾回收不要手动触发，尽量依靠JVM自身的机制 

在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。
JVM性能调优方法和步骤：
	1.监控GC的状态
	使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化。

	举一个例子： 系统崩溃前的一些现象：
   	每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，Full GC的时间也有之前的0.5s延长到4、5s
    Full GC的次数越来越多，最频繁时隔不到1分钟就进行一次Full GC
    年老代的内存越来越大并且每次FullGC后年老代没有内存被释放之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值，这个时候就需要分析JVM内存快照dump。

	2.生成堆的dump文件
	通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。

	3.分析dump文件
	打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux，几种工具打开该文件：

    Visual VM
    IBM HeapAnalyzer
    JDK 自带的Hprof工具
    Mat(Eclipse专门的静态内存分析工具)推荐使用

	备注：文件太大，建议使用Eclipse专门的静态内存分析工具Mat打开分析。

	4.分析结果，判断是否需要优化
	如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

	注：如果满足下面的指标，则一般不需要进行GC：
    Minor GC执行时间不到50ms；
    Minor GC执行不频繁，约10秒一次；
    Full GC执行时间不到1s；
    Full GC执行频率不算频繁，不低于10分钟1次；

	5.调整GC类型和内存分配
	如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择。

	6.不断的分析和调整
	通过不断的试验和试错，分析并找到最合适的参数，如果找到了最合适的参数，则将这些参数应用到所有服务器。 

JVM调优参数参考：
	1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;

	2.年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。
	比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

	3.年轻代和年老代设置多大才算合理
	1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC
	2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率
	如何选择应该依赖应用程序对象生命周期的分布情况： 如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性。

	在抉择时应该根 据以下两点：
	（1）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 。
	（2）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间。

	4.在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC 。

	5.线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。
	理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。